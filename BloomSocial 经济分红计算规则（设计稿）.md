> 本文档只描述 **“钱如何被计算与归属”**，不涉及 Solidity 代码、不涉及算法实现细节。 目标：把「经济分红」讲成**一套确定、可验证、不会出错的规则**。

---

## 一、基本参与方与资金来源

### 参与方

1. **作者（Creator）**：内容创作者
    
2. **点赞者（Liker）**：内容支持者
    
3. **协议（Protocol）**：提供规则与合约的系统角色
    

### 资金来源

- 所有可分配资金，**只来自点赞行为**

- 发布内容本身不产生收益（可选质押不计入分红）

### 点赞金额规则

- **点赞金额由作者在发布内容时设定**

- 每次点赞的金额是固定的（由作者决定）

- 每个地址对同一内容只能点赞一次

- 示例：作者设定点赞金额为 100 BLOOM，则所有点赞者每次点赞都支付 100 BLOOM
    

---

## 二、核心资金池划分（最重要）

### 每一次点赞都会产生一笔资金：`likeAmount`

这笔资金会被立即、按固定比例拆分为三部分：

1. **作者池（Author Pool）**
    
2. **点赞者奖励池（Liker Reward Pool）**
    
3. **协议金库（Treasury Pool）**
    

> 拆分发生在“点赞时”，而不是在最终结算时。

---

## 三、推荐的分配比例（默认参数）

> 所有比例都使用 **bps（万分比）** 表示，避免浮点误差。

|角色|比例|说明|
|---|---|---|
|作者|70%（7000 bps）|内容价值主要归属|
|点赞者|25%（2500 bps）|早期支持红利|
|协议|5%（500 bps）|平台公共资金|
|**合计**|**100%**|-|

> MVP 阶段协议费用为 **5%**，用于平台运营和未来发展。

---

## 四、点赞时的资金处理规则

当某个用户对内容点赞，投入 `likeAmount` 时：

1. **计算协议费用**
    
    - `protocolFee = likeAmount * protocolBps`
        
2. **计算作者分成**
    
    - `authorShare = likeAmount * authorBps`
        
3. **计算进入点赞者奖励池的金额**
    
    - `likerReward = likeAmount - protocolFee - authorShare`
        
4. 状态更新
    
    - 作者池 += authorShare
        
    - 点赞者奖励池 += likerReward
        
    - 协议金库 += protocolFee
        

> 所有钱在这一刻就已经“定性”，只是尚未被领取。

---

## 五、作者收益的计算规则

- 作者收益来源：
    
    - 所有点赞中分配给作者的那一部分
        
- 作者可领取金额：
    
    - = 作者池累计金额
        
- 作者**不能提前领取**，必须等内容结束（Finalized）后一次性领取
    

> 设计目的：防止作者中途抽走资金，破坏参与者信心。

---

## 六、点赞者收益的计算规则（概念层）

> 点赞者收益不在点赞当下确定，而是“随时间逐步累积”。

### 关键概念

- 每一次点赞都会：
    
    - 给之前所有点赞者“增加一部分可得奖励”
        
- 每个点赞者的最终收益，取决于：
    
    - 自己点赞时的**权重**
        
    - 所有后来点赞行为带来的增量
        

> 点赞者不是拿固定返利，而是参与一个持续增长的奖励池。

---

## 七、点赞者奖励的最终计算时机（懒惰计算机制）

> 本项目采用**懒惰计算（Lazy Evaluation）**：不需要单独的 Finalize 步骤，截止时间一到即可领取。

### 1. 为什么不需要 Finalize？

区块链上没有"自动执行"——所有状态变更都需要有人发起交易。

传统方案的问题：
- 需要有人调用 `finalize()` 函数
- 如果没人调用，用户无法领取

懒惰计算的优势：
- 零额外 Gas 开销
- 截止时间一到，立即可领取
- 完全去中心化，不依赖任何人/服务

### 2. 内容状态判定

```
if (当前时间 < 截止时间) {
    状态 = Active（进行中）
    → 可以点赞，不能领取
} else {
    状态 = Ended（已结束）
    → 不能点赞，可以领取
}
```

### 3. 领取时的计算流程

当用户调用领取函数时：

```
1. 检查：当前时间 ≥ 截止时间？
   - 否 → 拒绝，内容还在进行中
   - 是 → 继续

2. 检查：该用户已领取过？
   - 是 → 拒绝，不可重复领取
   - 否 → 计算奖励并转账
```

### 4. 关键结论

- 点赞者奖励池的总额：在**最后一个点赞发生后**已确定
- 每个点赞者的可领取金额：在**截止时间到达后**可计算
- 实际发放时机：用户**主动调用领取**时

> 每个点赞者只能领取一次

---

## 八、协议金库（Treasury）的计算规则

- 协议金库的来源：
    
    - 每一次点赞中分配给协议的那一部分
        
- 协议金库资金用途（不在 MVP 范围内）：
    
    - 平台补贴
        
    - 内容激励
        
    - DAO 治理
        

---

## 九、必须满足的经济安全约束

1. **总金额守恒**
    
    - 所有点赞投入的代币 = 作者收益 + 点赞者奖励 + 协议金库
        
2. **不可重复领取**
    
    - 作者、点赞者均只能领取一次
        
3. **规则前置、不可篡改**
    
    - 分红比例在内容创建时确定
        
4. **结算后不可变更**
    
    - 内容 Finalized 后，结果不可修改
        

---

## 十、这一套设计的教学价值

- 让读者理解：
    
    - Web3 项目中“钱不是随便转的”
        
    - 每一次资金流动都必须有明确归属
        
- 这套规则可以自然延展到：
    
    - 流动性挖矿
        
    - NFT 版税
        
    - DAO 金库分配
        

---

## 十一、点赞者权重的定义（Early-bird 机制）

> 本节定义：**“谁更早支持，谁在奖励池里占更大份额”**。 本项目明确约束：**每个地址对同一篇内容只能点赞一次**。

---

### 1. 为什么需要权重，而不是平均分？

如果点赞者奖励池平均分配：

- 第 1 个点赞者和第 100 个点赞者收益一样
    
- 早期支持没有任何优势
    

这会导致：

- 没人愿意在内容早期支持
    
- 内容冷启动困难
    

因此需要一个规则：

> **越早支持，权重越高，未来分到的奖励越多**。

---

### 2. 权重的唯一输入：点赞时间

在当前设计中（MVP）：

- 权重只与**点赞发生的时间**有关
    
- 与点赞金额无关（因为每人只能点赞一次）
    

这样可以保证：

- 规则简单、可解释
    
- 不会被“大户多投”破坏公平
    

---

### 3. 按点赞先后顺序定义权重（最终采用方案）

> 本项目**最终采用：按点赞先后顺序（Like Order）定义权重**，而不是按时间函数衰减。 原则非常直观：**谁先点赞，谁权重更高**。

---

#### 3.1 基本规则

- 每篇内容都有一个递增的 `likeIndex`
    
    - 第 1 个点赞者：`likeIndex = 1`
        
    - 第 2 个点赞者：`likeIndex = 2`
        
    - 第 N 个点赞者：`likeIndex = N`
        
- 每个点赞者的权重 **只由自己的点赞顺序决定**
    
- 点赞顺序一旦确定，不会再发生变化
    

---

#### 3.2 数学公式顺序权重（最终采用配置）

> 为避免“后期用户完全没有动力”，本项目将权重从阶梯改为**连续衰减 + 下限（floor）**的数学函数。 原则仍然直观：**越早点赞，权重越高**；但即使很晚点赞，也仍然拥有**非零权重**，从而保持参与动机。

---

##### 3.2.1 权重输入

- `i = likeIndex`（第 i 个点赞者，i 从 1 开始递增）
    
- 每个地址对同一内容只能点赞一次，因此每人只有一个 i
    

---

##### 3.2.2 推荐权重函数（带下限的指数衰减｜**最终确认采用**）

> **最终确认：采用指数衰减权重，且权重下限固定为** `**w_min = 0.2**`。 该方案在保证早期强激励的同时，避免后期参与动机被完全压制。

定义：

- `w_max = 1.0`（首个点赞者的最大权重）
    
- `w_min = 0.2`（权重下限，确保后期用户仍有参与意义）
    
- `k = 0.20`（衰减速度，冷启动友好）
    

权重函数：

- **w(i) = 0.2 + 0.8 · exp(-0.20 · (i - 1))**
    

直观效果：

- 第 1 个点赞者接近最高权重（≈1.0）
    
- 前 5–10 个点赞者权重差异明显
    
- 随着点赞人数增加，权重平滑下降
    
- 长尾阶段权重稳定在 0.2，不会归零
    

说明：

- 该函数只依赖 `likeIndex`，不依赖时间或金额
    
- 权重在点赞时一次性确定，后续不可修改
    
- 参数在内容创建时锁定，防止事后调整
    

---

##### 3.2.3 可选权重函数（带下限的幂律衰减）

如果你更偏好“先来优势更持久”的曲线，可用幂律（尾部更厚）：

- **w(i) = w_min + (w_max - w_min) / (i^p)**
    

其中 p 通常取 0.5 ~ 1.5。

---

##### 3.2.4 参数建议（冷启动默认值）

为兼顾冷启动（前 10 名差异明显）与后期参与动机（尾部不为 0），给出一组默认建议：

- `w_max = 1.0`
    
- `w_min = 0.2`
    
- `k = 0.20`（指数衰减）
    

说明：

- 这组参数会让前几位优势明显，但第 20、50 位仍有可解释的权重份额。
    
- 参数属于“协议可配置项”，但在某篇内容创建后应锁定。
    

---

##### 3.2.5 产品级解释（给用户看的那句话）

> “越早点赞，你在点赞者奖励池里占的份额越大； 但即使你来得晚，也仍然能占到一份固定的最低份额。”

---

#### 3.3 为什么从阶梯改为数学公式？

选择「顺序权重」而不是「时间衰减」的原因：

1. **认知成本极低**
    
    - 不需要理解时间函数
        
    - 只要知道：_先来先得_
        
2. **完全符合直觉与公平感**
    
    - 不会出现“早 1 秒和早 1 天差别巨大”的感受
        
3. **天然防刷**
    
    - 因为不允许多次点赞
        
    - 先后顺序不可被同一地址操纵
        
4. **教学表达极其清晰**
    
    - 非常适合第一次接触 Web3 经济模型的学员
        

---

#### 3.4 顺序权重对用户行为的影响

- 早期点赞者：
    
    - 明确知道自己是“前几名支持者”
        
    - 有很强的心理锚点（第 1 / 第 5 / 第 10 个）
        
- 中后期点赞者：
    
    - 明确自己更多是在为内容价值付费
        
- 作者：
    
    - 有动力尽早获得前几位支持者
        

---

#### 3.5 与实时展示 + 延迟领取的配合

- 点赞发生后：
    
    - 系统即可根据当前顺序权重
        
    - 实时计算并展示：
        
        - 当前预计可得奖励
            
- 内容截止并 Finalized 后：
    
    - 顺序与权重锁定
        
    - 用户才可以领取最终奖励
        

---

### 4. 权重的产品级描述（非数学）

你可以这样向学员或用户解释：

> “你支持得越早， 你在这篇内容的‘奖励池股份’就越多。 后面来的人， 会不断给这些股份注入价值。”

---

### 5. 实时可见、延迟领取的结算方式

本项目采用：

- **实时计算可得奖励**
    
    - 用户在前端可以看到：
        
        - 当前预计可领取奖励
            
        - 随着后续点赞不断增长
            
- **延迟领取（Claim）**
    
    - 只有在内容截止并 Finalized 后
        
    - 才允许真正领取代币
        

这样做的好处：

- 用户体验好（即时反馈）
    
- 规则稳定（结算后不可变）
    

---

### 6. 权重规则带来的行为结果

- 早期点赞者：
    
    - 有动力尽早支持
        
    - 有动力帮助内容传播
        
- 晚期点赞者：
    
    - 明确知道自己是“为内容付费”
        
    - 而不是为了投机返利
        
- 作者：
    
    - 希望尽快获得早期支持
        
    - 希望内容持续传播
        

---

### 7. 重要边界说明

- 不允许多次点赞
    
    - 每个地址对同一内容只能拥有一次权重
        
- 权重在点赞时确定
    
    - 后续不可变更
        
- 权重只影响点赞者奖励池
    
    - 不影响作者收益
        

---

---

## 十二、点赞者奖励的完整分配公式

> 本节定义：**每个点赞者最终能领取多少代币**，将概念层的权重转化为可计算的金额。

---

### 1. 核心分配原则

点赞者奖励池（likerRewardPool）按**权重比例**分配给所有点赞者：

- 每个点赞者的份额 = 自己的权重 / 所有点赞者的权重之和

---

### 2. 分配公式

#### 2.1 输入变量

| 变量 | 含义 |
|------|------|
| `N` | 内容结束时的总点赞人数 |
| `likerRewardPool` | 点赞者奖励池总额（所有点赞的 25% 累加） |
| `w(i)` | 第 i 个点赞者的权重（由权重函数计算） |

#### 2.2 权重函数（回顾）

```
w(i) = 0.2 + 0.8 × exp(-0.20 × (i - 1))
```

其中 i 从 1 开始（第 1 个点赞者）。

#### 2.3 权重总和

```
W_total = Σ w(i)  // i 从 1 到 N
       = w(1) + w(2) + ... + w(N)
```

#### 2.4 每个点赞者的可领取金额

```
reward(i) = likerRewardPool × w(i) / W_total
```

**公式解释**：
- 第 i 个点赞者的奖励 = 奖励池总额 × (自己的权重 / 权重总和)
- 这确保所有点赞者的奖励之和 = likerRewardPool（守恒）

---

### 3. 数值示例

假设一篇内容有 **5 个点赞者**，每人点赞 **100 BLOOM**：

#### 3.1 资金池计算

| 指标 | 计算 | 结果 |
|------|------|------|
| 总点赞金额 | 5 × 100 | 500 BLOOM |
| 作者池 (70%) | 500 × 0.70 | 350 BLOOM |
| 点赞者奖励池 (25%) | 500 × 0.25 | **125 BLOOM** |
| 协议金库 (5%) | 500 × 0.05 | 25 BLOOM |

#### 3.2 权重计算

| 点赞者 | i | w(i) = 0.2 + 0.8×exp(-0.2×(i-1)) | 权重值 |
|--------|---|----------------------------------|--------|
| 第 1 人 | 1 | 0.2 + 0.8×exp(0) | **1.000** |
| 第 2 人 | 2 | 0.2 + 0.8×exp(-0.2) | **0.855** |
| 第 3 人 | 3 | 0.2 + 0.8×exp(-0.4) | **0.736** |
| 第 4 人 | 4 | 0.2 + 0.8×exp(-0.6) | **0.639** |
| 第 5 人 | 5 | 0.2 + 0.8×exp(-0.8) | **0.559** |
| **合计** | - | - | **W_total = 3.789** |

#### 3.3 奖励分配

| 点赞者 | 权重占比 | 可领取奖励 | 净收益 |
|--------|----------|------------|--------|
| 第 1 人 | 1.000/3.789 = 26.4% | 125 × 26.4% = **33.0 BLOOM** | +33.0 - 25 = **+8.0** |
| 第 2 人 | 0.855/3.789 = 22.6% | 125 × 22.6% = **28.2 BLOOM** | +28.2 - 25 = **+3.2** |
| 第 3 人 | 0.736/3.789 = 19.4% | 125 × 19.4% = **24.3 BLOOM** | +24.3 - 25 = **-0.7** |
| 第 4 人 | 0.639/3.789 = 16.9% | 125 × 16.9% = **21.1 BLOOM** | +21.1 - 25 = **-3.9** |
| 第 5 人 | 0.559/3.789 = 14.8% | 125 × 14.8% = **18.4 BLOOM** | +18.4 - 25 = **-6.6** |
| **合计** | 100% | **125 BLOOM** | - |

> **解读**：前 2 位点赞者获得正收益，后 3 位点赞者净亏损——这正是「早期支持红利」的设计目的。

---

### 4. 实时预览计算（内容进行中）

用户在点赞后、内容结束前，可以看到「预计可领取奖励」：

#### 4.1 实时计算公式

在任意时刻 t，已有 M 个点赞者，当前奖励池为 `currentPool`：

```
预计奖励(i) = currentPool × w(i) / W_current
```

其中 `W_current = Σ w(j)`，j 从 1 到 M。

#### 4.2 为什么只是「预计」

- 后续可能有更多点赞者加入
- 新点赞者会：
  - 增加 `currentPool`（注入新资金）
  - 增加 `W_current`（稀释现有份额）
- 但由于新点赞者权重较低，早期点赞者的**绝对收益会增加**

---

### 5. 边界情况处理

#### 5.1 只有 1 个点赞者

| 情况 | 处理方式 |
|------|----------|
| N = 1 | 唯一点赞者获得整个 likerRewardPool |
| 公式 | reward(1) = likerRewardPool × 1.0 / 1.0 = likerRewardPool |

**示例**：唯一点赞者投入 100 BLOOM
- 作者池：70 BLOOM
- 点赞者奖励池：25 BLOOM → 全部归该点赞者
- 该点赞者净收益：25 - 25 = **0 BLOOM**（不亏不赚）

> 设计意图：单人点赞不产生「早期红利」，但也不会亏损。

#### 5.2 无人点赞

| 情况 | 处理方式 |
|------|----------|
| N = 0 | 所有资金池为 0，无需分配 |

#### 5.3 作者自己点赞

| 策略 | 说明 |
|------|------|
| **允许**（MVP 采用） | 作者可作为第 1 个点赞者，享受早期权重 |
| 限制 | 未来版本可禁止作者地址点赞自己的内容 |

---

### 6. 合约实现要点（概念层）

#### 6.1 存储结构

```
每篇内容需要存储：
- likeCount: 当前点赞人数 N
- likerRewardPool: 点赞者奖励池累计金额
- W_total: 权重总和（每次点赞时累加）
- likers[address]: 每个点赞者的 likeIndex
- claimed[address]: 是否已领取
```

#### 6.2 点赞时更新

```
当第 i 个用户点赞时：
1. likeCount += 1
2. likerRewardPool += likeAmount × 25%
3. 计算 w(i) 并累加到 W_total
4. 记录 likers[msg.sender] = i
```

#### 6.3 领取时计算

```
当用户领取时：
1. 获取 i = likers[msg.sender]
2. 计算 w(i)
3. reward = likerRewardPool × w(i) / W_total
4. 转账 reward 给用户
5. 标记 claimed[msg.sender] = true
```

---

### 7. 总结：分配公式一览

| 公式 | 表达式 |
|------|--------|
| 权重函数 | `w(i) = 0.2 + 0.8 × exp(-0.20 × (i-1))` |
| 权重总和 | `W_total = Σ w(i), i = 1..N` |
| 个人奖励 | `reward(i) = likerRewardPool × w(i) / W_total` |
| 守恒验证 | `Σ reward(i) = likerRewardPool` ✓ |

---

## 十三、BLOOM 代币说明

> BLOOM 是本项目的原生代币，用于所有点赞和奖励结算。

### 1. 代币基本信息

| 属性 | 值 |
|------|------|
| 代币名称 | Bloom Token |
| 代币符号 | BLOOM |
| 代币标准 | ERC-20 |
| 小数位数 | 18 |
| 部署网络 | 测试网（Sepolia / Base Sepolia） |

### 2. 代币用途

- **点赞支付**：用户使用 BLOOM 对内容点赞
- **奖励结算**：作者收益、点赞者奖励均以 BLOOM 发放
- **协议金库**：协议费用以 BLOOM 形式进入金库

### 3. 代币获取方式（测试阶段）

| 方式 | 说明 |
|------|------|
| Faucet | 官方测试水龙头领取 |
| Uniswap | 测试网 Uniswap 用 ETH 兑换 |

### 4. Uniswap 流动性配置

测试环境将在 Uniswap V3 上创建 BLOOM/ETH 交易对：

- 初始流动性由项目方提供
- 用户可通过 Uniswap 获取 BLOOM
- 价格由市场供需决定
